package{	import org.tomasino.events.DataEvent;	import flash.display.MovieClip;	import flash.events.Event;	import flash.geom.Point;	import flash.utils.Dictionary;		public class ScatterPoint extends MovieClip	{		private var _center:Point;		private var _size:Number;		private var _vector:Point;		private var _movedLastPhase:Point;				private static const FALLOFF:Number = 7;		private static const REPULSION:Number = 30;		private var _constraints:Array = new Array ();		private var _bubble:Bubble;		private var _errorTest:Boolean = false;		private var _isEnabled:Boolean = false;				public function ScatterPoint (size:Number = -1, x:Number = -1, y:Number = -1, vector:Point = null):void		{			super ();						_vector = new Point ();			_center = new Point ();			_movedLastPhase = new Point ();						if (size != -1) _size = size;			if (x != -1) _center.x = this.x = x;			if (y != -1) _center.y = this.y = y;			if (vector) _vector = _vector;						addEventListener (Event.ADDED_TO_STAGE, onAdd);		}				public function start ():void		{			_isEnabled = true;		}				private function onAdd(e:Event):void		{			removeEventListener(Event.ADDED_TO_STAGE, onAdd);						var resetPosition:Boolean = !(_center.x || _center.y);			createGraphics ( resetPosition );					addEventListener (Event.ENTER_FRAME, onFrame);		}				private function createGraphics(resetPosition:Boolean = false):void		{			_size = (!size) ? Math.random () * 10 + 5 : size;						_bubble = new Bubble ();			_bubble.width = _size * 2;			_bubble.scaleY = _bubble.scaleX;			_bubble.alpha = .8;			addChild (_bubble);						if (resetPosition)			{				this.x = Math.random () * this.stage.stageWidth;				this.y = Math.random () * this.stage.stageHeight;			}						var de:DataEvent = new DataEvent (DataEvent.START, true);			de.data = this;			dispatchEvent ( de );		}				override public function set x (_x:Number):void		{			super.x = _x;			_center.x = _x;		}				override public function set y (_y:Number):void		{			super.y = _y;			_center.y = _y;		}				public function dist (p:ScatterPoint):Number		{			var x1:Number = (p.x - _center.x);			var y1:Number = (p.y - _center.y);			var d:Number = Math.sqrt ( (x1 * x1) + (y1 * y1) );			return d - (_size + p.size);		}				public function vectorForce ( p:ScatterPoint ):Point		{			var dist:Number = dist (p);			var force:Point = new Point ();			if (dist < _size)			{				var angle:Number = Math.atan2 ( p.y - _center.y, p.x - _center.x );				dist = dist / 3;				force = Point.polar ( dist, angle);			}						return force;		}				private function onFrame(e:Event):void		{			if (_isEnabled)			{				// Basic movement				_movedLastPhase.x = (Math.abs(_vector.x) < .1) ? _vector.x : _vector.x / FALLOFF;				_movedLastPhase.y = (Math.abs(_vector.y) < .1) ? _vector.y :_vector.y / FALLOFF;				_center.x = this.x += _movedLastPhase.x;				_center.y = this.y += _movedLastPhase.y;				_vector.x = _vector.x - _movedLastPhase.x;				_vector.y = _vector.y - _movedLastPhase.y;								// Check bounds				if (this.y > this.stage.stageHeight)				{					this.y = 0;				}				else if (this.y < 0)				{					this.y = this.stage.stageHeight;				}				else if (this.x < 0)				{					this.x = this.stage.stageWidth;				}				else if (this.x > this.stage.stageWidth)				{					this.x = 0;				}								// Add Mouse Instigator				var mouseX:Number = this.stage.mouseX;				var mouseY:Number = this.stage.mouseY;				var mousePoint:Point = new Point (mouseX, mouseY);				var mouseDist:Number = Point.distance ( _center, mousePoint ) - size;								if (mouseDist < REPULSION)				{					var mouseAngle:Number = Math.atan2 ( _center.y - mousePoint.y, _center.x - mousePoint.x);					var mouseForce:Point = Point.polar ( REPULSION * 2, mouseAngle);					_vector.x = _vector.x + mouseForce.x;					_vector.y = _vector.y + mouseForce.y;				}												// Calculate Constraints				var totalConstraints:int = 0;				var mergePoints:Array = new Array ();				for (var i:int = 0; i < _constraints.length; ++i)				{					try					{						var constraint:ScatterPoint = _constraints[i] as ScatterPoint;						if (constraint && constraint.isEnabled)						{							var v:Point = vectorForce ( constraint ) ;														if (v.x || v.y)							{								if (constraint.size < 25)								{									totalConstraints ++;									if (totalConstraints > 4)									{										mergePoints.push  ( constraint );									}								}							}							// Constraints effect the vector							_vector.x = _vector.x + v.x;							_vector.y = _vector.y + v.y;						}					}					catch (e:Error) { }				}								// Splitting				var scalar:Number = Point.distance (_vector, new Point (0, 0) );								if (5000 / size < scalar)				{					var numToSplit:Number = Math.floor ( size / 6 );					var newSizes:Number = _size / numToSplit;										for (i = 0; i < numToSplit; ++i)					{						var spX:Number = this.x + (Math.random () * 10 - 5);						var spY:Number = this.y + (Math.random () * 10 - 5);						var sp:ScatterPoint = new ScatterPoint (newSize, spX, spY, new Point (_vector.x, _vector.y));						this.parent.addChild (sp);					}										this.destroy ();					return;				}								// Merging				if (totalConstraints > 4)				{					if (scalar < 1 && size < 25)					{						var newSize:Number = _size;						var newX:Number = this.x;						var newY:Number = this.y;						var numMergePoints:int = mergePoints.length;												for (i = 0; i < numMergePoints; ++i)						{							var mergePoint:ScatterPoint = mergePoints[i] as ScatterPoint;							newSize += mergePoint.size;							newX += mergePoint.x;							newY += mergePoint.y;							mergePoint.destroy ();						}												var average:Number = (newSize / (numMergePoints + 1));						newSize = average * (1 + (numMergePoints * .5));						newX = newX / (numMergePoints + 1);						newY = newY / (numMergePoints + 1);												var newSP:ScatterPoint = new ScatterPoint (newSize, newX, newY);						this.parent.addChild (newSP);						this.destroy ();												return;					}				}			}		}				public function addConstraint ( scatterPoint:ScatterPoint ):void		{			if ((scatterPoint != this) && (_constraints.indexOf (scatterPoint) == -1))				_constraints.push (scatterPoint);		}				public function removeConstraint ( scatterPoint:ScatterPoint ):void		{			var index:int = _constraints.indexOf (scatterPoint);			if (index != -1) _constraints.splice (index, 1);		}				public function destroy ():void		{			removeEventListener (Event.ENTER_FRAME, onFrame);			_bubble.addEventListener (Event.COMPLETE, onBubbleComplete);			_bubble.gotoAndPlay (2);			_errorTest = true;			_isEnabled = false;		}				private function onBubbleComplete(e:Event):void		{			var de:DataEvent = new DataEvent (DataEvent.COMPLETE, true);			de.data = this;			dispatchEvent (de);		}				public function get size():Number { return _size; }				public function set size(value:Number):void		{			_size = value;		}				public function get isEnabled():Boolean { return _isEnabled; }	}}